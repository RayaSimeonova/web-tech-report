<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Работа на уеб клиентите - част 2</title>

    <link rel="stylesheet" href="./css/reset-css.css">
    <link rel="stylesheet" href="./css/style.css">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0" />

    <script src="./javascript/script.js" defer></script>
</head>
<body id="root">

    <main>

        <div id="nav-wrapper" class="nav-wrapper">
            <button id="menu-btn" class="btn">
                <span class="material-symbols-outlined">menu</span>
            </button>

            <div id="nav-container" class="container nav">

                <div id="theme-toggler">
                    <button id="switch-btn" class="btn">
                        <span class="material-symbols-outlined switch-theme-icon" id="dark">dark_mode</span>
                        <span class="material-symbols-outlined switch-theme-icon hidden" id="light">light_mode</span>
                    </button>
                </div>
        
                <nav id="page-nav"> 
                    <h4 id="nav-header">Съдържание:</h4>
                    <ol>
                        <li class="nav-li">
                            <a href="#rendering">Рендиране на страници</a>
                            <ol>
                                <li class="nav-li inner-li"> 
                                    <a href="#dom">Генериране на DOM дърво</a> 
                                </li>
                                <li class="nav-li inner-li"> 
                                    <a href="#cssom">Генериране на CSSOM дърво</a> 
                                </li>
                                <li class="nav-li inner-li"> 
                                    <a href="#style">Генериране на Render дърво</a> 
                                </li>
                                <li class="nav-li inner-li"> 
                                    <a href="#layout">Фаза на оформлението</a> 
                                </li>
                                <li class="nav-li inner-li"> 
                                    <a href="#paint">Фаза на рисуване</a> 
                                </li>
                                <li class="nav-li inner-li"> 
                                    <a href="#compositing">Фаза на композиране</a> 
                                </li>
                                <li class="nav-li inner-li"> 
                                    <a href="#scripts">Изпълнение на скриптове</a> 
                                </li>
                            </ol>
                        </li>
        
                        <li class="nav-li">
                            <a href="#event-handling">Обработка на събития</a>
                            <ol>
                                <li class="nav-li inner-li"> 
                                    <a href="#receiving">Получаване на събитие</a> 
                                </li>
                                <li class="nav-li inner-li"> 
                                    <a href="#target">Целта на събитие</a> 
                                </li>
                                <li class="nav-li inner-li"> 
                                    <a href="#listener">Слушатели на събития</a> 
                                </li>
                                <li class="nav-li inner-li"> 
                                    <a href="#minimizing">Минимизиране на събитията към основната нишка</a> 
                                </li>
                            </ol>
                        </li>
        
                        <li class="nav-li">
                            <a href="#bibliography">Използвани източници</a>
                        </li>
        
                    </ol>
        
                </nav>
        
            </div>

        </div>
        
        <div id="content-container" class="container">

            <header id="page-header">
                <h1>Работа на уеб клиентите - част 2.
                    Рендиране на страници и обработка на събития
                </h1>
            </header>

            <article id="rendering" class="article">
                <header class="article-header">
                    <h2 class="article-heading">Рендиране на страници</h2>
                </header>

                <section class="section">
                    <p>
                        Процесът на рендиране е отговорен за всичко, което се случва вътре в таба. Основната му задача е да 
                        превърне HTML, CSS и JavaScript в уеб страница, с която потребителят може да взаимодейства <a href="#source-5">[5]</a>. 
                        За да го направи, преминава през поредица от събития, която се нарича критичен път на рендиране 
                        (critical rendering path) <a href="#source-4">[4]</a>.
                    </p>

                    <figure>
                        <img src="./img/crp.png" alt="Critical rendering path">
                        <figcaption>Фиг. 1. Критичен път на рендиране <a href="#source-8">[8]</a> </figcaption>
                    </figure>

                </section>

                <section id="dom" class="section">

                    <h3 class="section-heading">Генериране на DOM дърво</h3>

                    <p>
                        При опит за отваряне на  HTML файл в браузър, браузърът чете необработените байтове HTML от твърдият диск 
                        (или получени по мрежата, ако са в отговор на изпратена заявка към сървър за извличане на HTML документ), 
                        не действителните знаци от кода, които са написани <a href="#source-1">[1]</a>. 
                    </p>
                    
                    <p>
                        Когато файл се запази с <code>.html</code> разширение, това сигнализира на browser enginе-ът, че този файл трябва да се 
                        интерпретира като HTML документ. Начинът, по който браузърът интерпретира такива файлове е като първо ги 
                        анализира (парсва) <a href="#source-1">[1]</a>. 
                    </p>

                    <p>
                        Анализирането (Парсването) означава да се вземе кода, който пишем като текст (HTML, CSS) и да се трансформира 
                        в нещо, с което браузърът може да работи. Парсването на HTML включва две стъпки: токенизация и изграждане на 
                        дърво. <a href="#source-6">[6]</a>
                        По време на именно този процес на парсване и по-специално токенизацията се отчита всеки HTML таг във 
                        файла <a href="#source-1">[1]</a>. 
                    </p>

                    <p>
                        Първо, необработените байтове данни се преобразуват в знаци. Това преобразуване се извършва въз основа на 
                        кодирането на знаците (енкодинга) на HTML файла. Знаците допълнително се преобразуват в нещо, наречено токени
                        <a href="#source-2">[2]</a>. 
                    </p>

                    <p>
                        Концептуално, токенът е нещо като структура от данни, която съдържа информация за конкретния HTML таг <a href="#source-1">[1]</a>. 
                        Включват начални и крайни тагове, както и имена и стойности на атрибути <a href="#source-3">[3]</a>. Парсерът разбира всеки string 
                        в ъгловите скоби и съответно разбира множеството от правила, които важат за всеки от тях. Например, токен, 
                        който представя <code>anchor</code> таг, ще има различни характеристики от <code>paragraph</code> токен
                        <a href="#source-1">[1]</a>. 
                    </p>
                    
                    <figure>
                        <img src="./img/tokenization.png" alt="Tokenization during DOM creation">
                        <figcaption>Фиг. 2. Резултат от токенизацията <a href="#source-6">[6]</a></figcaption>
                    </figure>

                    <p>
                        След края на токенизацията, всички токени браузърът превръща в JavaScript обекти, наречени възли (Nodes) <a href="#source-1">[1]</a>. 
                        Тъй като всеки HTML елемент има различни свойства, обектът Node ще бъде създаден от различни класове. 
                        Например Node обектът за елемента <code>div</code> е създаден от <code>HTMLDivElement</code>, който наследява класа Node <a href="#source-4">[4]</a>.
                    </p>

                    <p>
                        След като браузърът е създал възли от HTML документа, той трябва да създаде дървовидна структура от тези 
                        възлови обекти. Тъй като нашите HTML елементи в HTML файла са вложени един в друг, браузърът трябва да копира 
                        това, но използвайки Node обекти, които е създал преди това. Това ще помогне на браузъра ефективно да визуализира 
                        и управлява уеб страницата през целия й жизнен цикъл. <a href="#source-4">[4]</a>
                    </p>

                    <p>
                        Създадената дървовидна структура от данни се нарича DOM дърво. Връзката между всеки възел се установява в този 
                        DOM обект <a href="#source-1">[1]</a>.
                    </p>

                    <p>
                        DOM дървото започва от най-горния елемент, който е <code>html</code> елемент, и се разклонява според появата и влагането 
                        на HTML елементи в документа. Всеки път, когато бъде намерен HTML елемент, той създава обект DOM възел (Node) 
                        от съответния му клас. <a href="#source-4">[4]</a>
                    </p>

                    <p>
                        DOM възелът не винаги трябва да бъде HTML елемент. Когато браузърът създава DOM дърво, той също записва неща 
                        като коментари, атрибути, текст като отделни възли в дървото <a href="#source-4">[4]</a>. Това може да се забележи и на фиг. 2, където в 
                        DOM дървото е отразенo и текстовото съдържание на HTML елементите <code>p</code> и <code>span</code>.
                    </p>
                    
                    <figure>
                        <img src="./img/dom-creation.PNG" alt="DOM tree">
                        <figcaption>Фиг. 3. Процес на създаване на DOM дърво <a href="#source-2">[2]</a></figcaption>
                    </figure>


                </section>

                <section id="cssom" class="section">
                    <h3 class="section-heading">Генериране на CSSOM дърво</h3>
                    <p>
                        Типичен HTML файл с малко CSS ще има линк-нат външен файл със стилове (например style.css). Докато браузърът 
                        получава необработените байтове данни и стартира процеса на конструиране на DOM дървото, той също така ще 
                        направи заявка за извличане на линк-натия CSS файл style.css. Веднага след като браузърът започне да парсва 
                        HTML файла, при намиране на <code>link</code> таг към CSS файл, той едновременно прави заявка за извличането му. 
                        Браузърът също така получава необработените байтове CSS данни от локалния диск (или по мрежата), при което с 
                        тях се инициира подобен процес на този с необработени байтове HTML, тъй като браузърът трябва да преобразува 
                        получените CSS правила в нещо, с което може да работи. С други думи, необработените байтове данни се преобразуват 
                        в знаци, след което се токенизират. Също така се формират възли и накрая се формира дървовидна структура, 
                        наречена CSSOM (CSS Object Model) <a href="#source-1">[1]</a>. Всеки възел в това дърво съдържа информация за стила на CSS, която ще бъде 
                        приложена към DOM елементи, към които е насочен (посочен от селектора). CSSOM обаче не съдържа DOM елементи, 
                        които не могат да бъдат отпечатани на екрана като <code>&lt;meta&gt;</code>, <code>&lt;script&gt;</code>,  
                        <code>&lt;title&gt;</code> и т.н <a href="#source-4">[4]</a>.
                    </p>

                    <figure>
                        <img src="./img/cssom-creation.png" alt="CSSOM creation process">
                        <figcaption>Фиг. 4. Етапи на създаване на CSSOM дърво <a href="#source-7">[7]</a></figcaption>
                    </figure>

                    <p>
                        Но за разлика от DOM дървото, изграждането на CSSOM дърво не е инкрементално (браузърът няма да обработва 
                        съдържанието на файла със стиловата таблица байт по байт) и трябва да се случи по специфичен начин. Причината 
                        за това е, че CSS правило в края на файла може да замени CSS правило, написано в горната част на файла. Би било 
                        неприятно потребителско изживяване да се види елементи да променят стилове на екрана, докато CSS се парсва. Тъй 
                        като CSS стиловете са каскадни, една промяна на правилото може да засегне много елементи <a href="#source-4">[4]</a>.
                    </p>

                    <p>
                        Браузърите имат собствена таблица със стилове по подразбиране, наречена user agent stylesheet. 
                        Браузърът първо изчислява окончателните CSS свойства за DOM елемент, като заменя стиловете по подразбиране 
                        със CSS, предоставен от разработчиците (използвайки правила за специфичност) и след това конструира възела 
                        <a href="#source-4">[4]</a>. 
                    </p>

                    <p>
                        Дори ако CSS свойство (като <code>display</code>) за конкретен HTML елемент не е дефинирано нито от разработчика, 
                        нито от браузъра, неговата стойност е зададена на стойността по подразбиране на това свойство, както е 
                        посочено от W3C CSS стандарта. Докато се избира стойността по подразбиране на CSS свойство, се използват 
                        някои правила за наследяване, ако дадено свойство отговаря на условията за наследяване, както е споменато 
                        в документацията на W3C. Например цвят и размер на шрифта, наследяват стойността на родителя, ако тези 
                        свойства липсват за HTML елемент. Това се нарича каскадно подреждане на стилове и затова CSS е съкращение 
                        от Cascading Style Sheets. Това е самата причина, поради която браузърът конструира CSSOM, дървовидна 
                        структура за изчисляване на стилове, базирани на CSS каскадни правила, т.е. браузърът трябва рекурсивно 
                        да премине през CSS дървовидната структура и да определи стиловете, които засягат определен елемент <a href="#source-4">[4]</a>.
                    </p>

                    <p>
                        На фиг. 5 стиловете в сив цвят (<code>font-size</code>, <code>font-weight</code> на <code>span</code> елемента) 
                        са наследени от родителя, а тези в черен са зададени от разработчика <a href="#source-2">[2]</a>.
                    </p>

                    <figure>
                        <img src="./img/cssom.PNG" alt="CSSOM tree">
                        <figcaption>Фиг. 5. CSSOM дърво <a href="#source-2">[2]</a></figcaption>
                    </figure>

                </section>

                <section id="style" class="section">
                    <h3 class="section-heading">Генериране на Render (Style) дърво</h3>
                    <p>
                        Render дървото също е дървовидна структура, изградена чрез комбиниране на DOM и CSSOM дърветата <a href="#source-4">[4]</a>. 
                    </p>

                    <p>
                        Kонструкцията започва с корена на DOM дървото, преминавайки през всеки видим възел. Тъй като Render 
                        дървото е представяне на ниско ниво на това, което в крайна сметка ще бъде отпечатано на екрана, 
                        тагове, които няма да бъдат показани, като <code>&lt;head&gt;</code> и неговите деца и всички възли с 
                        <code>display: none</code>, като например <code>script { display: none; }</code>, не са включени в Render дървото, 
                        тъй като няма да се появят в изобразения изход. Възлите с <code>visibility: hidden</code> са включени в дървото 
                        за изобразяване, тъй като заемат място. <a href="#source-3">[3]</a>
                    </p>

                    <p>
                        Скритият елемент ще присъства в DOM дървото, но не и в Render дървото. Това е така, защото дървото за 
                        изобразяване комбинира информация както от DOM, така и от CSSOM, така че знае да не включва скрит елемент 
                        в дървото <a href="#source-1">[1]</a>.
                    </p>

                    <p>
                        Всеки видим възел има своите CSSOM правила, приложени към него. Render дървото съдържа всички видими възли 
                        със съдържание и изчислени стилове — съпоставяне на всички съответни стилове към всеки видим възел в DOM дървото 
                        и определяне, въз основа на CSS каскадата, какви са изчислените стилове за всеки възел <a href="#source-3">[3]</a>.
                    </p>

                    <p>
                        На Фиг. 6 е показано, че Render дървото комбинира DOM и CSSOM, за да генерира дървовидна структура, съдържаща 
                        само елементите, които ще бъдат отпечатани на екрана. Тъй като в CSSOM, <code>p</code> елементът, разположен 
                        вътре в <code>div</code>, има <code>display: none;</code> стил, зададен върху него, той и неговите деца няма 
                        да присъстват в Render дървото, тъй като не заемат място на екрана. Ако обаче имате елементи с 
                        <code>visibility: hidden</code> или <code>opacity: 0</code>, те ще заемат място на екрана, следователно ще 
                        присъстват в Render дървото <a href="#source-4">[4]</a>.
                    </p>

                    
                    <figure>
                        <img src="./img/render-tree.PNG" alt="Render tree">
                        <figcaption>Фиг. 6. Процес на създаване на Render дърво <a href="#source-9">[9]</a></figcaption>
                    </figure>

                </section>

                <section id="layout" class="section">
                    <h3 class="section-heading">Фаза на оформлението</h3>
                    <p>
                        След конструирането на Render дървото следващата стъпка на браузърa е да създаде оформлението на всеки възел 
                        от него. Тъй като Render дървото идентифицира кои възли се показват (дори и невидими) заедно с техните изчислени 
                        стилове, но не и размерите или местоположението на всеки възел, тази стъпка на оформлението е важна. Тя взема 
                        предвид съдържанието и стила, получени от DOM и CSSOM, и извършва всички необходими геометрични изчисления за 
                        оформлението <a href="#source-1">[1]</a>.
                    </p>

                    <p>
                        Оформлението е процесът, чрез който се определят ширината, височината и местоположението на всички възли в Render 
                        дървото, плюс определянето на размера и позицията на всеки обект на страницата. За да определи точния размер и 
                        местоположение на всеки обект, браузърът започва от основата на Render дървото и го обикаля <a href="#source-3">[3]</a>.
                    </p>

                    <p>
                        На уеб страницата почти всичко е кутия. Различните устройства и различните предпочитания за работния плот 
                        означават неограничен брой различни размери на прозореца за изглед. В тази фаза, като взема предвид размера 
                        на прозореца за изглед, браузърът определя какви ще бъдат размерите на всички различни кутии на екрана. Вземайки 
                        размера на прозореца за изглед като основа, оформлението обикновено започва с <code>body</code> елементът, 
                        определяйки размерите на всички негови наследници, със свойствата на модела на кутията за всеки елемент 
                        <a href="#source-3">[3]</a>. На фиг. 7 е показан именно резултатът от този процес на оформление - модел, 
                        подобен на кутия, който улавя точно къде трябва да бъде всеки елемент на екрана и неговия размер <a href="#source-8">[8]</a>.
                    </p>
                    
                    <figure>
                        <img src="./img/layout-result.png" alt="Layout result">
                        <figcaption>Фиг. 7. Резултат от процеса на оформление <a href="#source-8">[8]</a></figcaption>
                    </figure>

                    <p>
                        Процесът се нарича оформление само първия път, когато размерът и позицията на възлите се определят. 
                        Последващите преизчисления на размера и местоположенията на възлите се наричат преформатиране (reflow) <a href="#source-3">[3]</a>. 
                        Те се изчисляват, когато промяната в уеб страницата засяга оформлението на страницата и позицията 
                        на нейните елементи. Този процес на преформатиране може да се задейства, 
                        когато се скролва, преоразмерява прозореца или се манипулират DOM елементи. 
                        В процеса на преформатиране ще се преизчисли позицията на всички елементи в DOM, включително дъщерния и 
                        родителския компонент, дори ако промените засягат един елемент <a href="#source-4">[4]</a>.
                    </p>

                    <p>
                        Но тъй като оформлението е скъпа операция (дори най-простото оформление на страницата, като поток от блокове 
                        отгоре надолу, трябва да вземе предвид колко голям е шрифтът и къде да прекъсне реда, защото това влияе на 
                        размера и формата на параграфа; което след това засяга мястото, където трябва да бъде следващият параграф), 
                        по-скоро трябва да се избягва уеб страницата да преминава през множество операции по преформатиране поради 
                        незначителни причини <a href="#source-5">[5]</a>.
                    </p>

                </section>

                <section id="paint" class="section">
                    <h3 class="section-heading">Фаза на рисуване</h3>

                    <p>
                        Render дървото и оформлението на елементите все още не са достатъчни, за да може браузъра да рендира страницата. 
                        Знае се размера, формата и местоположението на елементите, но все пак трябва да се прецени и реда им на рисуване 
                        <a href="#source-5">[5]</a>.
                    </p>

                    <p>
                        В тази стъпка на рисуване основната нишка обикаля Render дървото, за да създаде записи за рисуване. Записът е 
                        бележка за процеса на рисуване като "първо фон, след това текст, след това правоъгълник" <a href="#source-5">[5]</a>. 
                    </p>

                    <p>
                        След като вече е известен и редът на подреждане на елементите, в процеса на рисуване или растеризация браузърът 
                        преобразува всяко поле, изчислено във фазата на оформление, в действителни пиксели на екрана. Рисуването включва 
                        изчертаване на всяка визуална част от елемент на екрана, включително текст, цветове, граници, сенки и заменени 
                        елементи като бутони и изображения <a href="#source-3">[3]</a>. 
                    </p>

                    <p>
                        Може би наивен начин да се извърши процеса на растеризация би бил частите да се растеризират вътре в прозореца 
                        за изглед. Ако потребителят скролне страницата, растерната рамка се премества и липсващите части се попълват, 
                        като се растеризира повече <a href="#source-5">[5]</a>.
                    </p>

                    <figure>
                        <img src="./img/naive-rasterization.PNG" alt="Naive Rasterization">
                        <figcaption>Фиг. 8. Наивен начин за растеризация <a href="#source-5">[5]</a></figcaption>
                    </figure>

                    <p>
                        Но на всяка стъпка от процеса на рендиране на страница резултатът от предишната операция се използва за създаване 
                        на нови данни. Затова ако нещо се промени в оформлението, редът на рисуване трябва да се генерира отново за 
                        засегнатите части от документа <a href="#source-8">[8]</a>.
                    </p>

                    <p>
                        Това прерисуване на страницата, което следва, браузърът трябва да направи много бързо. Затова модерният браузър 
                        изпълнява процес, наречен композиране <a href="#source-5">[5]</a>.
                    </p>

                </section>

                <section id="compositing" class="section">
                    <h3 class="section-heading">Фаза на композиране</h3>

                    <p>
                        Композирането е техника за разделяне на части от страница на слоеве, растеризирането им поотделно и комбиниране 
                        като страница в отделна нишка, наречена нишка за композиране. Ако се скролне, тъй като слоевете вече са 
                        растеризирани, всичко, което трябва да се направи, е да се композира нов кадър <a href="#source-5">[5]</a>.
                    </p>

                    <p>
                        Така браузърът ефективно извършва операции по рисуване през целия жизнен цикъл на уеб страница, като например 
                        докато се скролва или преоразмерява прозореца на браузъра <a href="#source-4">[4]</a>. 
                    </p>

                    <p>
                        За да се уточни кои елементи трябва да бъдат в кои слоеве, основната нишка преминава през дървото на оформлението, 
                        за да създаде дървото на слоевете. Ако определени части от страница, които трябва да бъдат отделен слой 
                        (като плъзгащо се странично меню), не получават такъв, тогава това може да се намекне на браузъра, като се 
                        използва атрибута <code>will-change</code> в CSS. Всъщност има специфични свойства и елементи, които сигнализират 
                        за създаването на нов слой. Някои от тях са <code>&lt;video&gt;</code>, <code>&lt;canvas&gt;</code> и всеки 
                        елемент, който има свойствата на CSS <code>opacity</code>, <code>3D трансформация</code>, <code>will-change</code> 
                        и няколко други. Тези възли ще бъдат нарисувани върху техния собствен слой, заедно с техните наследници <a href="#source-8">[8]</a>.
                    </p>

                    <p>
                        След като дървото на слоевете е създадено и са определени редовете за рисуване, основната нишка предава тази 
                        информация на нишката на композитора. След това нишката на композитора растеризира всеки слой. Един слой може 
                        да бъде голям като цялата дължина на страница, така че нишката на композитора ги разделя на плочки и изпраща 
                        всяка плочка към растерни нишки. Растерните нишки растеризират всяка плочка и ги съхраняват в паметта на GPU 
                        <a href="#source-5">[5]</a>. 
                    </p>

                    <figure>
                        <img src="./img/rastering-tiles.PNG" alt="Rasterization">
                        <figcaption>Фиг. 9. Растеризация <a href="#source-5">[5]</a></figcaption>
                    </figure>

                    <p>
                        Нишката на композитора може да даде приоритет на различни растерни нишки, така че нещата в прозореца за изглед 
                        (или в близост) да могат да бъдат растеризирани първи <a href="#source-5">[5]</a>.
                    </p>

                    <p>
                        След като плочките са растеризирани, нишката на композитора събира информация за плочките, наречена draw quads 
                        (местоположението на плочката в паметта и къде в страницата да начертаете плочката, като вземете предвид 
                        композирането на страницата), за да създаде композиционна рамка. Тези композиционна рамки се изпращат до 
                        графичния процесор, за да го покажат на екран. Ако се появи скрол събитие, нишката на композитора създава 
                        друга композиционна рамка, която да бъде изпратена до GPU-то <a href="#source-5">[5]</a>.
                    </p>

                    <figure>
                        <img src="./img/compositing.PNG" alt="compositing">
                        <figcaption>Фиг. 10. Процес на композиране <a href="#source-5">[5]</a></figcaption>
                    </figure>

                </section>

                <section id="scripts" class="section">
                    <h3 class="section-heading">Изпълнение на скриптове</h3>

                    <p>
                        Всеки път, когато браузърът срещне външен ресурс като скрипт чрез 
                        <code>&lt;script src="url"&gt;&lt;/script&gt;</code> елемент, файл със стилове (CSS) чрез 
                        <code>&lt;link rel="stylesheet" href="url"/ &gt;</code> етикет, файл с изображение чрез 
                        елемент <code>&lt;img src="url" /&gt;</code> или всеки друг външен ресурс, браузърът ще започне изтеглянето на 
                        този файл във фонов режим <a href="#source-4">[4]</a>. 
                    </p>

                    <p>
                        Основната нишка може да ги изисква един по един, когато ги намира, докато анализира, за да изгради DOM, но за да 
                        се ускори процесът, „скенерът за предварително зареждане“ се изпълнява едновременно. Ако има неща като 
                        <code>&lt;img&gt;</code> или <code>&lt;link&gt;</code> в HTML документа, скенерът за предварително зареждане 
                        надниква в токените, генерирани от HTML анализатора, и изпраща заявки към мрежовата нишка в процеса на браузъра 
                        <a href="#source-5">[5]</a>.
                    </p>

                    <p>
                        Създаването на DOM дървото обикновено се случва в главната нишка. Така че, ако основната нишка е заета, 
                        създаването на DOM няма да напредне, докато нишката не е свободна. Всяка заявка за външен файл като изображение, 
                        таблица със стилове, pdf, видео и т.н. не блокира конструкцията на DOM, освен заявките за скрипт (.js) 
                        <a href="#source-3">[3]</a>. 
                    </p>

                    <p>
                        Когато браузърът срещне <code>script</code> елемент, ако това е вграден скрипт, той първо ще изпълни този скрипт 
                        и след това ще продължи да парсва HTML, за да конструира DOM дървото. Така че всички вградени скриптове блокират 
                        парсерите <a href="#source-4">[4]</a>.
                    </p>

                    <p>
                        Ако <code>script</code> елементът е външен скриптов файл, браузърът ще започне изтеглянето на външния скриптов файл във фонов 
                        режим, но ще спре изпълнението на основната нишка, докато този файл не бъде изтеглен. Това означава, че 
                        конструирането на DOM дървото е паузирано, докато не бъде изтеглен скриптовият файл. След като скриптовият 
                        файл бъде изтеглен, браузърът първо ще изпълни изтегления скриптов файл в главната нишка и след това ще 
                        продължи с конструирането на DOM. Ако браузърът отново намери друг скриптов елемент в HTML, той ще извърши 
                        същата операция <a href="#source-4">[4]</a>. 
                    </p>

                    <p>
                        Браузърът трябва да спира конструирането на DOM дървото, докато JavaScript не бъде изтеглен и изпълнен, защото 
                        излага DOM API-то на JavaScript runtime, което означава, че можем да осъществяваме достъп и да манипулираме DOM 
                        елементи от JavaScript (може да се променя структурата на DOM дървото) <a href="#source-4">[4]</a>.
                    </p>

                    <p>
                        Въпреки това спирането на конструирането на DOM, докато скриптът се изтегля във фонов режим, в повечето случаи е 
                        напълно ненужно. Следователно HTML5 ни дава атрибута <code>async</code> за <code>script</code> елемента. Когато 
                        парсерът срещне външен елемент на скрипт с атрибут <code>async</code>, той няма да спре процеса на конструиране 
                        на DOM дървото, докато файлът на скрипта се изтегля във фонов режим. Но след като файлът бъде изтеглен, 
                        парсването ще спре и скриптът (кодът) ще бъде изпълнен <a href="#source-4">[4]</a>.
                    </p>

                    <p>
                        Имаме и атрибут <code>defer</code> за <code>script</code> елемента, който работи подобно на атрибута 
                        <code>async</code>, но за разлика от него, скриптът не се изпълнява дори когато файлът е напълно изтеглен. 
                        Всички скриптове се изпълняват, след като целия HTML е парснат, което означава, че DOM дървото е напълно 
                        конструирано <a href="#source-4">[4]</a>. 
                    </p>

                </section>

            </article>
            
            <article id="event-handling" class="article">
                <header class="article-header">
                    <h2 class="article-heading">Обработка на събития</h2>
                </header>

                <section class="section">

                    <p>
                        Обработката на събития в уеб браузърите се отнася до способността на уеб страницата да открива и реагира на 
                        действията на потребителя и други събития, които се случват в браузъра.
                    </p>

                    <p>
                        От гледна точка на браузъра, събитие (input event) означава всеки жест от потребителя - въвеждане в текстово 
                        поле, клик с мишката, скролване, докосване, mouse over <a href="#source-10">[10]</a>. 
                    </p>

                    <p>
                        Тези събития се обработват от процеса на рендиране по подходящ начин чрез намиране на целта на събитието и 
                        стартиране на слушатели на събития, които са прикачени. Слушателят на събития е функция, която се изпълнява 
                        при възникване на събитие.
                    </p>

                </section>

                <section id="receiving" class="section">
                    <h3 class="section-heading">Получаване на събитие</h3>
                    <p>
                        Когато се появи потребителски жест като докосване на екрана, процесът на браузъра е този, който получава жеста 
                        първо. Процесът на браузъра обаче знае само къде се е случил този жест, тъй като съдържанието вътре в раздела се 
                        обработва от процеса на рендиране. Така че процесът на браузъра изпраща типа на събитието (като 
                        <code>touchstart</code>) и неговите координати към процеса на рендиране <a href="#source-10">[10]</a>. 
                    </p>

                    <p>
                        Композиторът може да обработва гладко скролване чрез композиране на растеризирани слоеве. Ако към страницата не 
                        са прикачени слушатели на събития (event listeners), композитор нишката може да създаде нова композиционна рамка, 
                        напълно независимо от основната нишка. Но ако към регион от страницата има закачени слушатели, то този регион при 
                        композиране на страницата е маркиран като „Регион без бързо скролване“. Това означава, че ако събитие е 
                        задействано в този регион, композитор нишката изпраща събитието на главната нишка, защото на нея се изпълнява 
                        JavaScript-a, и изчаква да се изпълнят съответните зададени действия при среща на това събитие. В случай, че 
                        събитие е задействано извън този регион, композитор нишката си композира новата рамка без да чака главната нишка 
                        <a href="#source-10">[10]</a>.
                    </p>

                    <figure>
                        <img src="./img/browser-to-rendering.PNG" alt="Finding event target">
                        <figcaption>Фиг. 11. Входно събитие, насочено от процеса на браузъра към процеса на рендиране, където композитор 
                            нишката го предава на основната нишка <a href="#source-10">[10]</a>.
                        </figcaption>
                    </figure>

                    <p>
                        Ако обаче има голям „Регион без бързо скролване“, дори ако приложението не се интересува от входни събития, 
                        идващи от определени части на този регион, нишката на композитора трябва да комуникира с основната нишка и да 
                        я чака всеки път, когато влезе събитие. По този начин способността за плавно скролване на композитора не може 
                        да се наблюдава. За да се избегне това и да се подобри ефективността на скролването, може да се подаде 
                        <code>passive: true</code>  опцията в слушателя на събития. Това подсказва на браузъра, че в главната нишка 
                        може все още да се слуша за събитието, но композиторът може да продължи и да състави и нов кадър 
                        <a href="#source-10">[10]</a>.
                    </p>

                </section>

                <section id="target" class="section">
                    <h3 class="section-heading">Целта на събитие</h3>
                    <p>
                        Когато нишката на композитора изпрати събитие към основната нишка, първото нещо, което трябва да се изпълни, е 
                        тест за попадение, за да се намери целта на събитието. Тестът за попадение използва информацията от записите за 
                        рисуване, които са генерирани в процеса на рендериране (изобразяване), за да разбере какво има под координатите 
                        на точката, в която се е случило събитието <a href="#source-10">[10]</a>.
                    </p>

                    <figure>
                        <img src="./img/target.PNG" alt="Finding event target">
                        <figcaption>Фиг. 12. Основната нишка търси какво е нарисувано на координатите (x,y) <a href="#source-10">[10]</a> </figcaption>
                    </figure>

                </section>

                <section id="listener" class="section">
                    <h3 class="section-heading">Слушатели на събития</h3>
                    
                    <p>
                        Слушателите на събития се регистрират с помощта на JavaScript код, който се изпълнява в главната нишка на 
                        процеса на рендиране. Когато се регистрира слушател на събитие, той се добавя към списък със слушатели за 
                        конкретния тип събитие на таргет елемент. Този списък се съхранява в паметта на главната нишка на процеса 
                        на рендиране <a href="#source-14">[14]</a>. 
                    </p>

                    <p>
                        Когато се задейства събитие, процесът на рендиране проверява този списък, за да определи дали има регистрирани 
                        слушатели на събития за този тип събитие в таргет елемент или някой от неговите предци. Ако има регистрирани 
                        слушатели на събития, процесът на рендиране ще ги изпълни в реда, в който са регистрирани <a href="#source-14">[14]</a>.
                    </p>

                    <p>
                        По време на изпълнението на слушателите на събития, JavaScript кодът в слушателите може да модифицира DOM, 
                        като например добавяне или премахване на елементи, промяна на съдържанието или атрибутите на съществуващи 
                        елементи или модифициране на стила на елементите <a href="#source-13">[13]</a>. 
                    </p>

                    <p>
                        На код снипет 1 е показан регистриран слушател на събитие. <code>modifyText()</code> е слушател за събития 
                        от тип клик с мишка, регистрирани с помощта на <code>addEventListener()</code> за таргет елемент таблица с 
                        <code>id="outside"</code>. Кликване където и да е в таблицата се извежда до този слушател. при което се изпълнява 
                        <code>modifyText()</code> <a href="#source-14">[14]</a>.
                    </p>

                    <figure>

                        <pre>
                            <code class="code-example">
// Function to change the content of tаble row 2 (has id=t2)
function modifyText() {
    const t2 = document.getElementById("t2");
    const isNodeThree = t2.firstChild.nodeValue === "three";
    t2.firstChild.nodeValue = isNodeThree ? "two" : "three";
}

// Add event listener to table (has id=outside)
const el = document.getElementById("outside");
el.addEventListener("click", modifyText, false);                            
                            </code>
                        </pre>

                        <figcaption>Код снипет 1. Пример за слушател на събитие. <a href="#source-14">[14]</a></figcaption>

                    </figure>


                    <p>
                        След като обработката на събитието приключи, процесът на рендиране актуализира визуалния дисплей на уеб 
                        страницата въз основа на всички промени, направени в DOM по време на обработката на събитието. Този процес 
                        на актуализиране може да включва изпращане на команди към нишката за композиране, която е отговорна за 
                        изобразяването и композирането на визуалните елементи на уеб страницата <a href="#source-5">[5]</a>. 
                    </p>

                    <p>
                        Например, ако слушател на събития промени позицията или размера на визуален елемент на страницата, може да се
                        наложи основната нишка да информира нишката на композитора за новата позиция или размер, така че да може 
                        съответно да актуализира визуалното представяне на страницата <a href="#source-5">[5]</a>.
                    </p>

                    <p>
                        След това нишката на композитора може да генерира нов кадър за показване на екрана, включващ всички промени, 
                        направени по време на обработката на събитието <a href="#source-5">[5]</a>.
                    </p>

                </section>                

                <section id="minimizing" class="section">
                    <h3 class="section-heading">Минимизиране на събитията към основната нишка</h3>

                    <p>
                        Минимизирането на броя на събитията, изпратени до основната нишка, е важно за поддържане на плавно и отзивчиво 
                        потребителско изживяване в уеб приложенията. Ако твърде много събития се изпращат наведнъж към главната нишка, 
                        тя може да се претовари и страницата да изглежда бавна, да не реагира или дори да се срине 
                        <a href="#source-12">[12]</a>.
                    </p>

                    <p>
                        Типичният дисплей опреснява екрана 60 пъти в секунда. А пък от към входни събития типично устройство със сензорен 
                        екран доставя събитие за докосване 60-120 пъти в секунда, а типичната мишка доставя събития 100 пъти в секунда. 
                        Входното събитие се задейства по-бързо, отколкото браузърът може да рисува рамки за опресняване на екрана 
                        <a href="#source-10">[10]</a>. 
                    </p>

                    <p>
                        Интуитивно има смисъл защо това би се случило. 
                        Ако непрекъснато събитие като touchmove е изпратено до основната нишка 120 пъти в секунда, то може да задейства 
                        прекомерно количество тестове за попадение и изпълнение на JavaScript в сравнение с това колко бавно може да се 
                        опресни екранът <a href="#source-10">[10]</a>.
                    </p>

                    <p>
                        За да бъдат сведени до минимум прекомерните извиквания към главната нишка, множество подобни непрекъснати събития 
                        са обединени във едно 
                        (като <code>wheel</code>, <code>mousewheel</code>, <code>mousemove</code>, <code>pointermove</code>, 
                        <code>touchmove</code>) <a href="#source-10">[10]</a>.
                    </p>

                    <p>
                        Ако потребителят плъзга пръста си по екрана и pointermove се задейства 3 пъти за всеки кадър, тогава всъщност не 
                        ни интересуват първото и второто събитие. Ние се интересуваме само от третото, защото това е, което трябва да се 
                        нарисува <a href="#source-11">[11]</a>.
                    </p>

                    <figure>
                        <img src="./img/coalesced.PNG" alt="Coalesced events">
                        <figcaption>Фиг. 13. Сливане на събития и забавянето им до обновяването на кадъра <a href="#source-10">[10]</a></figcaption>
                    </figure>

                    <p>
                        Всички отделни събития като натискане на клавиш, натискане на мишката, стартиране на докосване и край на 
                        докосване се изпращат незабавно <a href="#source-10">[10]</a>.
                    </p>

                    <p>
                        В случай обаче, че координатите на целта зад всяко докосване на екрана са важни (както е например в приложенията 
                        за рисуване), може да се използва метода <code>getCoalescedEvents</code> на <code>pointer</code> събитието, за да бъде взета информацията 
                        за всяко от слетите събития. Така няма да се изгубят координатите по средата <a href="#source-10">[10]</a>.
                    </p>

                    <figure>
                        <pre >
                            <code class="code-example">
window.addEventListener('pointermove', event => {
    const events = event.getCoalescedEvents();
    for (let event of events) {
        const x = event.pageX;
        const y = event.pageY;
        // draw a line using x and y coordinates.
    }
});
                            </code>
                        </pre>                        
                        
                        <figcaption>Код снипет 2. Пример за използване на <code>getCoalescedEvents</code> <a href="#source-10">[10]</a>.</figcaption>
                    </figure>

                </section>


            </article>

            <section id="bibliography" class="article">

                <h2 class="article-heading">Използвани източници</h2>

                <ol class="section">
                    <li id="source-1" class="source">
                        [1] Emmanuel, Ohans. “How Browser Rendering Works — behind the Scenes - LogRocket Blog.” LogRocket Blog, 19 June 2021, 
                        <a href="https://blog.logrocket.com/how-browser-rendering-works-behind-scenes/">https://blog.logrocket.com/how-browser-rendering-works-behind-scenes/.</a>    
                    </li>

                    <li id="source-2" class="source">
                        [2] “---.” Web.Dev, 
                        <a href="https://web.dev/critical-rendering-path-constructing-the-object-model/">https://web.dev/critical-rendering-path-constructing-the-object-model/</a>. Accessed 17 Apr. 2023.    
                    </li>

                    <li id="source-3" class="source">
                        [3] “Populating the Page: How Browsers Work - Web Performance | MDN.” MDN Web Docs, 
                        <a href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#parsing"> https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#parsing</a>. Accessed 17 Apr. 2023.
    
                    </li>

                    <li id="source-4" class="source">
                        [4] Hiwarale, Uday. “How the Browser Renders a Web Page? — DOM, CSSOM, and Rendering | by Uday Hiwarale | JsPoint | Medium.” Medium, JsPoint, 2 Aug. 2019, 
                        <a href="https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969">https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969</a>.
      
                    </li>

                    <li id="source-5" class="source">
                        [5] “Inside Look at Modern Web Browser (Part 3) - Chrome Developers.” Chrome Developers, 
                        <a href="https://developer.chrome.com/blog/inside-browser-part3/">https://developer.chrome.com/blog/inside-browser-part3/</a>. Accessed 19 Apr. 2023,

                    </li>

                    <li id="source-6" class="source">
                        [6] Arika. “How Web Browsers Work - Parsing the HTML (Part 3, with Illustrations)📜🔥 - DEV Community.” DEV Community, DEV Community, 25 Apr. 2022, 
                        <a href="https://dev.to/arikaturika/how-web-browsers-work-parsing-the-html-part-3-with-illustrations-45fi">https://dev.to/arikaturika/how-web-browsers-work-parsing-the-html-part-3-with-illustrations-45fi</a>.
     
                    </li>


                    <li id="source-7" class="source">
                        [7] Arika. “How Web Browsers Work - Parsing the CSS (Part 4, with Illustrations)⏳🌐 - DEV Community.” DEV Community, DEV Community, 29 Apr. 2022, 
                        <a href="https://dev.to/arikaturika/how-web-browsers-work-parsing-the-css-part-4-with-illustrations-4c">https://dev.to/arikaturika/how-web-browsers-work-parsing-the-css-part-4-with-illustrations-4c</a>.
     
                    </li>

                    <li id="source-8" class="source">
                        [8] Arika. “How Web Browsers Work - the Render Tree (Part 7, with Illustrations)💻 ⏳ - DEV Community.” DEV Community, DEV Community, 1 June 2022,
                        <a href="https://dev.to/arikaturika/how-web-browsers-work-the-render-tree-part-7-with-illustrations-24h3">https://dev.to/arikaturika/how-web-browsers-work-the-render-tree-part-7-with-illustrations-24h3</a>.
      
                    </li>

                    <li id="source-9" class="source">
                        [9] “Render-Tree Construction, Layout, and Paint.” Web.Dev, 
                        <a href="https://web.dev/critical-rendering-path-render-tree-construction/">https://web.dev/critical-rendering-path-render-tree-construction/</a>. Accessed 29 Apr. 2023.
     
                    </li>

                    <li id="source-10" class="source">
                        [10] “Inside Look at Modern Web Browser (Part 4) - Chrome Developers.” Chrome Developers, 
                        <a href="https://developer.chrome.com/blog/inside-browser-part4/#be-aware-when-you-write-event-handlers">https://developer.chrome.com/blog/inside-browser-part4/#be-aware-when-you-write-event-handlers</a>. Accessed 20 Apr. 2023.
     
                    </li>

                    <li id="source-11" class="source">
                        [11] “High-Performance Input Handling on the Web | Read the Tea Leaves.” Read the Tea Leaves, https://www.facebook.com/WordPresscom, 11 Aug. 2019, 
                        <a href="https://nolanlawson.com/2019/08/11/high-performance-input-handling-on-the-web/">https://nolanlawson.com/2019/08/11/high-performance-input-handling-on-the-web/</a>.
     
                    </li>

                    <li id="source-12" class="source">
                        [12] “Minimize Main Thread Work - Chrome Developers.” Chrome Developers, 
                        <a href="https://developer.chrome.com/en/docs/lighthouse/performance/mainthread-work-breakdown/">https://developer.chrome.com/en/docs/lighthouse/performance/mainthread-work-breakdown/</a>. Accessed 29 Apr. 2023.
      
                    </li>

                    <li id="source-13" class="source">
                        [13] Okere, Chibuike. “How to Manipulate the DOM - the Ultimate Beginner’s Guide.” FreeCodeCamp.Org, freeCodeCamp.org, 19 Jan. 2021, 
                        <a href="https://www.freecodecamp.org/news/how-to-manipulate-the-dom-beginners-guide/">https://www.freecodecamp.org/news/how-to-manipulate-the-dom-beginners-guide/</a>.
     
                    </li>

                    <li id="source-14" class="source">
                        [14] “Event Handling (Overview) - Event Reference | MDN.” MDN Web Docs, 
                        <a href="https://developer.mozilla.org/en-US/docs/Web/Events/Event_handlers">https://developer.mozilla.org/en-US/docs/Web/Events/Event_handlers</a>. Accessed 29 Apr. 2023.
      
                    </li>

                </ol>

            </section>

            <footer id="footer">
                <small>УЕБ Технологии 2023 Рая Симеонова (ф.н. 62557)</small>
            </footer>
        </div>

    </main>

</body>
</html>